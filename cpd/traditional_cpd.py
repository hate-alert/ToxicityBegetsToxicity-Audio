# -*- coding: utf-8 -*-
"""Podcast_Time_Series.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V5wrm0241wDtKFOO5nG027qRgcGQanu1
"""

import json

with open('/Users/naquee.rizwan/Desktop/fear-speech/cpd/dataset/top_toxic_chains_conservatives.json', 'r') as data_string:
    data = json.load(data_string)

"""# CPD Algorithms

Cost Models
"""

rbf_model = "rbf"
cosine_model = "cosine"
l2_model = "l2"
linear_model = "linear" # Internally runs "l2" itself

"""Detection Algorithm"""

import ruptures as rpt

jump = 1
min_size = 1
penalty = 1.0

detection_algo = [
    rpt.Pelt(model=rbf_model, jump=jump, min_size=min_size),
    # rpt.Pelt(model=cosine_model, jump=jump, min_size=min_size),
    # rpt.Pelt(model=l2_model, jump=jump, min_size=min_size),

    rpt.KernelCPD(kernel=rbf_model, jump=jump, min_size=min_size),
    # rpt.KernelCPD(kernel=cosine_model, jump=jump, min_size=min_size),
    # rpt.KernelCPD(kernel=linear_model, jump=jump, min_size=min_size),

    # rpt.Window(model=rbf_model, jump=jump, min_size=min_size),
    # rpt.Window(model=cosine_model, jump=jump, min_size=min_size),
    # rpt.Window(model=l2_model, jump=jump, min_size=min_size),

    rpt.BottomUp(model=rbf_model, jump=jump, min_size=min_size),
    # rpt.BottomUp(model=cosine_model, jump=jump, min_size=min_size),
    # rpt.BottomUp(model=l2_model, jump=jump, min_size=min_size),

    rpt.Binseg(model=rbf_model, jump=jump, min_size=min_size),
    # rpt.Binseg(model=cosine_model, jump=jump, min_size=min_size),
    # rpt.Binseg(model=l2_model, jump=jump, min_size=min_size)
]

"""Implementation"""

import matplotlib.pyplot as plt
import ruptures as rpt
import numpy as np
from tqdm import tqdm


# Note that all arrays are  (Zero-based Index)

output_break_points = {
    "chains": []
}

# Important note: Concatenated toxicity is the toxicity of current and previous segments combined

for chain in tqdm(data):

    concatenated_signal = []

    temporary_json = {

    }

    for index, element in enumerate(chain["Before Conversations"]):
        toxicity_val = 0.0 if len(element["TOXICITY"]) == 0 else max(element["TOXICITY"])
        concatenated_signal.append([toxicity_val if "Concatenated_Toxicity" not in element else element["Concatenated_Toxicity"]])

    for element in chain["Toxic Conversation"]:
        toxicity_val = 0.0 if len(element["TOXICITY"]) == 0 else max(element["TOXICITY"])
        concatenated_signal.append([toxicity_val if "Concatenated_Toxicity" not in element else element["Concatenated_Toxicity"]])

    for index, element in enumerate(chain["After Conversations"]):
        toxicity_val = 0.0 if len(element["TOXICITY"]) == 0 else max(element["TOXICITY"])
        concatenated_signal.append([toxicity_val if "Concatenated_Toxicity" not in element else element["Concatenated_Toxicity"]])

    temporary_json["Toxic Chain Index"] = chain["Toxic Chain Index"]

    temporary_json["Concatenated Signals"] = concatenated_signal

    for indexer, detect in enumerate(detection_algo):
        algo = detect.fit(np.array(concatenated_signal))
        result = algo.predict(pen=penalty)

        temporary_json[str(detect).split('.')[-1].split()[0]] = result

    output_break_points["chains"].append(temporary_json)

import json

for chain in tqdm(output_break_points["chains"]):

    # print ("Toxic Chain Index:", chain["Toxic Chain Index"])
    # print ("Concatenated Signals:", chain["Concatenated Signals"])

    algorithms_employed = ["Pelt", "KernelCPD", "BottomUp", "Binseg"]
    print(chain[algorithms_employed[0]])

    # for algo in algorithms_employed:
    #     print (algo, ":", chain[algo])
    #     rpt.display(np.array(chain["Concatenated Signals"]), chain[algo])
    #     plt.show()

